#+title: Objects

There are a few different ways of defining objects in JavaScript. One very common method is using object literals, which happens by listing its properties within braces:
#+begin_src javascript 
const object1 = {
  name: 'Yahia ABSI',
  age: 25,
  education: 'PhD',
}

const object2 = {
  name: 'Full Stack web application development',
  level: 'intermediate studies',
  size: 5,
}

const object3 = {
  name: {
    first: 'Khallad',
    last: 'Al-Joufi',
  },
  grades: [2, 3, 5, 3],
  department: 'Mechanical Engineering',
}
#+end_src
The values of the properties can be of any type, like integers, strings, arrays, objects...

The properties of an object are referenced by using the "dot" notation, or by using brackets:
#+begin_src javascript
console.log(object1.name)         // Arto Hellas is printed
const fieldName = 'age'
console.log(object1[fieldName])    // 35 is printed
#+end_src
You can also add properties to an object on the fly by either using dot notation or brackets:
#+begin_src javascript
object1.address = 'Safi'
object1['secret number'] = 12341
#+end_src
The latter of the additions has to be done by using brackets because when using dot notation, secret number is not a valid property name because of the space character.

Naturally, objects in JavaScript can also have methods.

Objects can also be defined using so-called constructor functions, which results in a mechanism reminiscent of many other programming languages, e.g. Java's classes. Despite this similarity, JavaScript does not have classes in the same sense as object-oriented programming languages. There has been, however, the addition of the class syntax starting from version ES6, which in some cases helps structure object-oriented classes.

* Object methods and "this"
 functions and functions defined using the function keyword vary substantially when it comes to how they behave with respect to the keyword this, which refers to the object itself.

We can assign methods to an object by defining properties that are functions:
#+begin_src javascript
const yahia = {
  name: 'Yahia ABSI',
  age: 25,
  education: 'PhD',
  greet: function() {
    console.log('hello, my name is ' + this.name)
  },
}

yahia.greet()  // "hello, my name is Yahia ABSI" gets printed
#+end_src
Methods can be assigned to objects even after the creation of the object:
#+begin_src javascript
const yahia = {
  name: 'Yahia ABSI',
  age: 25,
  education: 'PhD',
  greet: function() {
    console.log('hello, my name is ' + this.name)
  },
}

yahia.growOlder = function() {
  this.age += 1
}

console.log(yahia.age)   // 25 is printed
yahia.growOlder()
console.log(yahia.age)   // 26 is printed
#+end_src
Let's slightly modify the object:
#+begin_src javascript
const yahia = {
  name: 'Yahia ABSI',
  age: 35,
  education: 'PhD',
  greet: function() {
    console.log('hello, my name is ' + this.name)
  },
  doAddition: function(a, b) {
    console.log(a + b)
  },
}

yahia.doAddition(1, 4)        // 5 is printed

const referenceToAddition = yahia.doAddition
referenceToAddition(10, 15)   // 25 is printed
#+end_src
Now the object has the method doAddition which calculates the sum of numbers given to it as parameters. The method is called in the usual way, using the object =yahia.doAddition(1, 4)= or by storing a method reference in a variable and calling the method through the variable: =referenceToAddition(10, 15)=.

If we try to do the same with the method greet we run into an issue:
#+begin_src javascript
yahia.greet()       // "hello, my name is Arto Hellas" gets printed

const referenceToGreet = yahia.greet
referenceToGreet() // prints "hello, my name is undefined"
#+end_src
When calling the method through a reference, the method loses knowledge of what the original this was. Contrary to other languages, in JavaScript the value of this is defined based on how the method is called. When calling the method through a reference, the value of this becomes the so-called global object and the end result is often not what the software developer had originally intended.

* Class Syntax

As mentioned previously, there is no class mechanism in JavaScript like the ones in object-oriented programming languages. There are, however, features to make "simulating" object-oriented classes possible.

Let's take a quick look at the class syntax that was introduced into JavaScript with ES6, which substantially simplifies the definition of classes (or class-like things) in JavaScript.

In the following example we define a "class" called Person and two Person objects:
#+begin_src javascript
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  greet() {
    console.log('hello, my name is ' + this.name)
  }
}

const adam = new Person('Adam Ondra', 29)
adam.greet()

const janja = new Person('Janja Garnbret', 23)
janja.greet()
#+end_src
The type of any such class instance is still Object, because JavaScript fundamentally defines only a limited set of types: Boolean, Null, Undefined, Number, String, Symbol, BigInt, and Object.

